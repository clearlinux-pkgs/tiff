diff --git a/libtiff/tif_dirread.c b/libtiff/tif_dirread.c
index 6baa7b31..81afae14 100644
--- a/libtiff/tif_dirread.c
+++ b/libtiff/tif_dirread.c
@@ -165,6 +165,7 @@ static int TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uin
 static int TIFFFetchSubjectDistance(TIFF*, TIFFDirEntry*);
 static void ChopUpSingleUncompressedStrip(TIFF*);
 static uint64 TIFFReadUInt64(const uint8 *value);
+static int TIFFGetColorChannels(uint16 photometric);
 
 static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount );
 
@@ -3504,6 +3505,35 @@ static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, c
 	}
 }
 
+/*
+ * Return the number of color channels specified for a given photometric type.
+ * 0 is returned if photometric type isn't supported or no default value is
+ * defined by the specification.
+ */
+static int TIFFGetColorChannels( uint16 photometric )
+{
+    switch (photometric) {
+	case PHOTOMETRIC_PALETTE:
+	case PHOTOMETRIC_MINISWHITE:
+	case PHOTOMETRIC_MINISBLACK:
+            return 1;
+	case PHOTOMETRIC_YCBCR:
+	case PHOTOMETRIC_RGB:
+	case PHOTOMETRIC_CIELAB: /* can also be 1 in case of monochrome-L-only */
+            return 3;
+	case PHOTOMETRIC_SEPARATED:
+	case PHOTOMETRIC_MASK:
+            return 4;
+	case PHOTOMETRIC_LOGL:
+	case PHOTOMETRIC_LOGLUV:
+	case PHOTOMETRIC_CFA:
+	case PHOTOMETRIC_ITULAB:
+	case PHOTOMETRIC_ICCLAB:
+	default:
+            return 0;
+    }
+}
+
 /*
  * Read the next TIFF directory from a file and convert it to the internal
  * format. We read directories sequentially.
@@ -4024,6 +4054,27 @@ TIFFReadDirectory(TIFF* tif)
 			}
 		}
 	}
+
+	/*
+	 * Make sure all non-color channels are extrasamples.
+	 * If it's not the case, define them as such.
+	 */
+        if (TIFFGetColorChannels(tif->tif_dir.td_photometric) &&
+            tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > TIFFGetColorChannels(tif->tif_dir.td_photometric)) {
+		TIFFWarningExt(tif->tif_clientdata,module, "SamplesPerPixel higher than "
+                    "number of color channels without ExtraSamples. Defining non-standard "
+                    "channels as ExtraSamples");
+
+                int old_extrasamples = tif->tif_dir.td_extrasamples;
+                tif->tif_dir.td_extrasamples += ((tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples) - TIFFGetColorChannels(tif->tif_dir.td_photometric));
+
+                // sampleinfo should contain information relative to these new extra samples
+                uint16 new_sampleinfo[tif->tif_dir.td_extrasamples];
+                memset(new_sampleinfo, 0, tif->tif_dir.td_extrasamples);
+                memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));
+                _TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);
+        }
+
 	/*
 	 * Verify Palette image has a Colormap.
 	 */
diff --git a/libtiff/tif_print.c b/libtiff/tif_print.c
index 8deceb2b..1d86adbf 100644
--- a/libtiff/tif_print.c
+++ b/libtiff/tif_print.c
@@ -544,7 +544,7 @@ TIFFPrintDirectory(TIFF* tif, FILE* fd, long flags)
 				uint16 i;
 				fprintf(fd, "    %2ld: %5u",
 				    l, td->td_transferfunction[0][l]);
-				for (i = 1; i < td->td_samplesperpixel; i++)
+				for (i = 1; i < td->td_samplesperpixel - td->td_extrasamples && i < 3; i++)
 					fprintf(fd, " %5u",
 					    td->td_transferfunction[i][l]);
 				fputc('\n', fd);

